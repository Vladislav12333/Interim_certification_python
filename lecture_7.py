#1 ВАРИАНТ
# import modul1
# print(modul1.max1(5, 9))
#
#2 ВАРИАНТ
#from modul1 import max1
#print(max1(15, 9))
#
#3 ВАРИАНТ
# from modul1 import*
# print(max1(15, 9))
#
#4 ВАРИАНТ
# import modul1 as m1
# print(m1.max1(10, 9))



#Рекурсия
#
# Задача №1
# Пользователь вводит число n. Необходимо вывести n - первых членов последовательности Фибоначчи.
# Напоминание: Последовательно Фибоначчи, это такая последовательность, в которой каждое последующее число равно сумму 2-ух предыдущих.
# При описании рекурсии важно указать, когда функции надо остановиться и перестать вызывать саму себя. По-другому говоря, необходимо указать базис рекурсии.
# Решение:
# def fib(n):
#     if n in [1,2]:
#         return 1
#     return fib(n-1) + fib(n-2)
# list_1 = []
# for i in range(1, 10):
#     list_1.append(fib(i))
# print(list_1)



# Алгоритмы
# Быстрая сортировка
# Пример:
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать. 
# Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60, 73... 
# Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии "разделяй и властвуй".
# Обозначим друзей, друг_1 Иван, который загадал число, друг_2 это Петр, который отгадывает.
# Иван загадал число 77.
# Петр: Число больше 50? Иван: Да.
# Петр: Число больше 75? Иван: Да.
# Петр: Число больше 87? Иван: Нет.
# Петр: Число больше 81? Иван: Нет.
# Петр: Число больше 78? Иван: Нет.
# Петр: Число больше 76? Иван: Да.
# Число оказалось в диапазоне 76 < x < 78, значит это числдо 77. Задача решена. 
# На самом деле мы сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии "разделяй и властвуй". Давайте перейдем к обсуждению программного кода быстрой сортировки.
#
# Решение:
# def quick_sort(array):
#     if len(array) <= 1:
#         return array
#     else:
#         pivot = array[0]
#     less = [i for i in array[1:] if i <= pivot]
#     greater = [i for i in array[1:] if i > pivot]
#     return quick_sort(less) + [pivot] + quick_sort(greater)
# print(quick_sort([10, 5, 2])) 
#
# 1-е повторение рукурсии:
# array = [10,5,2]
# pivot = 10
# less = [5,2]
# greater = []
# return quicksort([5,2]) + [10] + quicksort([])
# 2-е повторение рукурсии:
# array = [5,2]
# pivot = 15
# less = [2]
# greater = []
# return quicksort([2]) + [5] + quicksort([]) #Важно! Не забывайте, что здесь помимо вызова рекурсии добавляется список [10]
# 3-е повторение рукурсии:
# array = [2]
# return [2] #Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2] + [5] + [10] = [2,5,10]

#Сортировка слиянием
# def merge_sort(nums):
#     if len(nums) > 1:
#         mid = len(nums) // 2
#         left =nums[:mid]
#         right =nums[mid:]
#         merge_sort(left)
#         merge_sort(right)
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 nums[k] = left[i]
#                 i += 1
#             else:
#                 nums[k] = right[j]
#                 j += 1
#             k += 1
#         while i < len(left):
#             nums[k] = left[i]
#             i += 1
#             k += 1
#         while j < len(right):
#             nums[k] = right[j]
#             j += 1
#             k += 1
# list1 = [1,5,6,9,8,7,2,1,55,2,4]           
# merge_sort(list1)
# print(list1)

