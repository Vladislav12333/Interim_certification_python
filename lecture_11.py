#Урок 11. Семинар. Функции высшего порядка

# Задача №47
# У вас есть код, который не можете менять (так часто бывает, когда код в глубине программы используется множество раз и вы не хотите ничего сломать): 
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Удинственный способ вашего взаимодействия с этим кодом - посредством задания функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился копией values.
# Ввод:
# values = [1, 23, 42, 'asdfg']
# transformed_values = list(map(trasformation, values))
# if values == transformed_values:
#   print('ok')
# else:
#   print('fail')
# Вывод:
# ok
#
# Решение:
# transformation = lambda x: x
# values = [1, 23, 42, 'asdfg']
# transformed_values = list(map(transformation, values))
# if values == transformed_values:
#   print('ok')
# else:
#   print('fail')



# Задача №49
# Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, по которой вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, зато искусственные спутники были запущены на круговые орбиты. Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - аолуосей ее эллипса. Площадь эллипса вычисляется по формуле S=pi*a*b, где a и b - длины полуосей эллипса. При решении задачи используйте списочный выражения. Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, а затем найти и сам эллипс, имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна
# Ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))
# Вывод:
# 2.5 10
#
# Решение:
# from math import pi
# def find_farthest_orbit(list_of_orbits):
#     list1 = [i for i in list_of_orbits if i [0] !=i[1]]
#     list_s = [(pi * i[0] * i[1]) for i in list1]
#     max_s = list_s.index(max(list_s))
#     return list1[max_s]
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))



# Задача №49
# Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты имеют одинаковое значение некоторой характеристики, и возвращают True, если это так. Если значение характеристики для разных объектов отличается - то False. Для пустого набора объектов, функция должна возвращать True. Аргумент characteristic - это функция, которая принимает объект и вычисляет его характеристику.
# Ввод:
# values = [0, 2, 10, 6]
# if same_by(lambda x: x % 2, values):
#   print('same')
# else:
#   print('different')
# Вывод:
# same
#
# Решение №1:
# def same_by(characteristic, objects):
#   # Если список объектов пуст, возвращаем True
#   if not objects:
#     return True
#   # Вычисляем значение характеристики для первого объекта
#   first_value = characteristic(objects[0])
#   # Проверяем, совпадает ли значение характеристики для всех остальных объектов
#   for obj in objects[1:]:
#     if characteristic(obj) != first_value:
#       # Если нашли различие, возвращаем False
#       return False
#   # Если все объекты имеют одинаковое значение характеристики, возвращаем True
#   return True
# # Пример использования функции
# values = [0, 2, 10, 6]
# if same_by(lambda x: x % 2, values):
#   print('same')
# else:
#   print('different')
#
# Решение №2:
# def same_by(characteristic, object):
#     result = True
#     list1 = [characteristic(x) for x in object]
#     for i in range(len(list1) - 1):
#         if list1[i] != list1[i+1]:
#             result = False
#     return result
# values = [0, 2, 10, 6]
# if same_by(lambda x: x % 2, values):
#   print('same')
# else:
#   print('different')



# Практическое задание
# Задача №1:
# Напишите функцию print_operation_table(operation, num_rows, num_columns), которая принимает в качестве аргумента функцию, вычисляющую элемент по номеру строки и столбца. По умолчанию номер столбца и строки = 9.
# Аргументы num_rows и num_columns указывают число строк и столбцов таблицы, которые должны быть распечатаны.
# Нумерация строк и столбцов идет с единицы (подумайте, почему не с нуля).
# Если строк меньше двух, выдайте текст
# ОШИБКА! Размерности таблицы должны быть больше 2!.
# Примечание: бинарной операцией называется любая операция, у которой ровно два аргумента, как, например, у операции умножения.
# Между элементами должен быть 1 пробел, в конце строки пробел не нужен.
# Пример
# На входе:
# print_operation_table(lambda x, y: x * y, 3, 3)
# На выходе:
# 1 2 3
# 2 4 6 
# 3 6 9
#
# Решени №1:
# def print_operation_table(operation, num_rows = 9, num_columns = 9):
#   # Проверяем, что число строк и столбцов больше двух
#   if num_rows < 2 or num_columns < 2:
#     # Выводим сообщение об ошибке
#     print("ОШИБКА! Размерности таблицы должны быть больше 2!")
#     return
#   # Создаем пустой список для хранения строк таблицы
#   table = []
#   # Для каждого номера строки от 1 до num_rows
#   for i in range(1, num_rows + 1):
#     # Создаем пустой список для хранения элементов строки
#     row = []
#     # Для каждого номера столбца от 1 до num_columns
#     for j in range(1, num_columns + 1):
#       # Вычисляем элемент таблицы с помощью функции operation
#       element = operation(i, j)
#       # Добавляем элемент в список row
#       row.append(element)
#     # Добавляем список row в список table
#     table.append(row)
#   # Для каждого списка row в списке table
#   for row in table:
#     # Преобразуем элементы row в строки и соединяем их пробелами
#     line = " ".join(str(x) for x in row)
#     # Выводим line на экран
#     print(line)
# # Пример использования функции
# print_operation_table(lambda x, y: x * y, 3, 3)
#
# Решени №2:
# def print_operation_table(operation, num_rows=9, num_columns=9):
#     result = []
#     if num_rows < 2 or num_columns < 2:
#         print('ОШИБКА! Размерности таблицы должны быть больше 2!')
#     else:
#         for i in range(1, num_rows + 1):
#             for j in range(1, num_columns + 1):
#                 if j != num_columns :
#                     result.append(f'{operation(i, j)} ')
#                 else:
#                     result.append(operation(i, j))
#             result.append('\n')
#         print(''.join([str(i) for i in result[:len(result) - 1]]))


# Задача №2: 
# Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. Поскольку разобраться в его кричалках не настолько просто, насколько легко он их придумывает, Вам стоит написать программу.
# Винни-Пух считает, что ритм есть, если число слогов (т.е. число гласных букв) в каждой фразе стихотворения одинаковое.
# Фраза может состоять из одного слова, если во фразе несколько слов, то они разделяются дефисами.
# Фразы отделяются друг от друга пробелами.
# Стихотворение  Винни-Пух передаст вам автоматически в переменную stroka в виде строки. В ответе напишите Парам пам-пам, если с ритмом все в порядке и Пам парам, если с ритмом все не в порядке.
# Если фраза только одна, то ритм определить не получится и необходимо вывести: Количество фраз должно быть больше одной!.
# Пример:
# На входе:
# stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'
# На выходе:
# Парам пам-пам
#
# Решение №1:
# stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'
# # Введите ваше решение ниже
# def check_rhythm(stroka):
#   # Разделяем строку на фразы по пробелам
#   phrases = stroka.split()
#   # Проверяем, что число фраз больше одной
#   if len(phrases) < 2:
#     # Выводим сообщение об ошибке
#     print("Количество фраз должно быть больше одной!")
#     return
#   # Создаем пустой список для хранения числа слогов в каждой фразе
#   syllables = []
#   # Для каждой фразы в списке phrases
#   for phrase in phrases:
#     # Считаем число гласных букв в фразе
#     vowels = sum(1 for c in phrase if c in "аеёиоуыэюя")
#     # Добавляем число слогов в список syllables
#     syllables.append(vowels)
#   # Проверяем, что все элементы списка syllables равны
#   if len(set(syllables)) == 1:
#     # Выводим Парам пам-пам, если ритм есть
#     print("Парам пам-пам")
#   else:
#     # Выводим Пам парам, если ритма нет
#     print("Пам парам")
# # Пример использования функции
# check_rhythm(stroka)
#
# Решение №2:
# vowels = ['а', 'е', 'ё', 'и', 'й', 'о', 'у', 'ы', 'э', 'ю', 'я']
# phrases = stroka.split()
# if len(phrases) < 2:
#  print('Количество фраз должно быть больше одной!')
# else:
#  countVowels = []
#  for i in phrases:
#   countVowels.append(len([x for x in i if x.lower() in vowels]))
#  if countVowels.count(countVowels[0]) == len(countVowels):
#   print('Парам пам-пам')
#  else:
#   print('Пам парам')